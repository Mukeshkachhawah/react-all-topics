Question 1. You are building a search input field that triggers an API call whenever the user types. However, you want to limit API requests so they only occur after the user stops typing for 500ms. How would you implement this?
Answer:You can use debouncing to limit API calls:
let debounceTimer;
function debounceSearch(callback, delay) {
  return function () {
    const args = arguments;
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(() => callback.apply(this, args), delay);
  };
}

function search(query) {
  console.log(`Searching for: ${query}`); // Replace with an actual API call
}

const input = document.getElementById('searchInput');
input.addEventListener('input', debounceSearch(() => search(input.value), 500));



Question 2. Scenario: Fixing a Variable Scope Issue in Loops
Aapko 1 se 5 tak numbers ko ek second ke delay ke saath console me log karna hai, lekin var use karne se sabhi logs 6 dikhate hain. Aap ise kaise fix karenge?

Answer-1 : Use let instead of var to create block-scoped variables:
for (let i = 1; i <= 5; i++) {
  setTimeout(() => console.log(i), i * 1000);
}
Answer-2 :Alternatively, using var with an IIFE (ImmediatelyInvoked Function Expression):
for (var i = 1; i <= 5; i++) {
    (function(i) {
        setTimeout(() => console.log(i), i * 1000);
        })(i);
    }

Question 3:Scenario: Implementing a Custom Promise
Ek simple custom Promise banaiye jo 2 seconds ke baad ek value resolve kare.
Answer :
class CustomPromise {
  constructor(executor) {
    this.onResolve = null;
    this.onReject = null;

    const resolve = (value) => {
      if (this.onResolve) {
        this.onResolve(value);
      }
    };

    const reject = (error) => {
      if (this.onReject) {
        this.onReject(error);
      }
    };

    executor(resolve, reject);
  }

  then(callback) {
    this.onResolve = callback;
    return this;
  }

  catch(callback) {
    this.onReject = callback;
    return this;
  }
}

const promise = new CustomPromise((resolve) => {
  setTimeout(() => resolve("Resolved after 2 seconds"), 2000);
});

promise.then((value) => {
  console.log(value);
  for (let i = 1; i <= 10; i++) {
    console.log(i);
  }
});

Question 4. Aapko ek object banana hai jo modify nahi kiya ja sake (koi property add, delete, ya change nahi ho sakti). Aap ise kaise karenge?
Answer : You can create an immutable object in JavaScript by using Object.freeze(). Here's an example:
const object = Object.freeze({
    name :"Mukks",
    age:"22",}
)
object.name = "Mukesh";  //type error
console.log(object.name);

Question 5 Scenario: Implementing a Polyfill for Array.prototype.map()
Is question ka matlab hai ki aapko Array.prototype.map() function ka polyfill likhna hai. Polyfill ka matlab hota hai ki agar 
kisi function ko browser support nahi karta hai, to hum us function ko manually implement kar sakein.


Answer : 
Array.prototype.map() ek built-in JavaScript method hai jo ek array ke har element par ek function apply karta hai aur uske result se ek naya array banata hai.

Polyfill ka matlab hai: agar aapko pata chale ki koi function, jaise map(), purane browsers mein supported nahi hai, to aap uska manually implementation karte ho, taaki wo function un browsers mein bhi kaam kare.

Array.prototype.myMap = function(callback) {
  const result = [];
  for (let i = 0; i < this.length; i++) {
    if (this.hasOwnProperty(i)) {
      result.push(callback(this[i], i, this));
    }
  }
  return result;
};

const numbers = [1, 2, 3];
const doubled = numbers.myMap(num => num * 2);
console.log(doubled);  // [2, 4, 6]
