Question 1. Q: Humara e-commerce website hai jisme bahut saare products hain. Hume products ko categories ke basis pe group karna hai aur har category ke top 5 most expensive products nikalne hain. Iska query kaise likhenge?
Answer :Pehle $group operator se products ko category wise group kiya
Fir $project and $slice se har category ke top 5 expensive products nikal liye
Scenario: User Activity Tracking
// First, we'll use aggregation pipeline
db.products.aggregate([
  // Step 1: Group by category
  { $group: {
      _id: "$category",
      products: { 
        $push: {
          name: "$name",
          price: "$price",
          description: "$description"
        }
      }
    }
  },
  // Step 2: Sort products within each group
  { $project: {
      category: "$_id",
      topProducts: {
        $slice: [
          { $sortArray: { 
              input: "$products", 
              sortBy: { price: -1 } 
          }}, 
          5
        ]
      }
    }
  }
])

Question 2.Humare website pe users ke last 24 hours ke actions track karne hain. User ne kitni baar login kiya, kya kya pages visit kiye, etc. Ye data kaise store karein aur query kaise karein?
Answer: 
// Document structure
{
  userId: ObjectId("..."),
  action: "LOGIN",
  timestamp: ISODate("2025-01-20T10:30:00Z"),
  details: {
    deviceType: "mobile",
    browser: "Chrome",
    ipAddress: "192.168.1.1"
  }
}

// Query for last 24 hours activity
db.userActivity.find({
  userId: ObjectId("user_id_here"),
  timestamp: {
    $gte: new Date(Date.now() - 24*60*60*1000)
  }
}).sort({timestamp: -1})

// Get count of actions by type
db.userActivity.aggregate([
  {
    $match: {
      userId: ObjectId("user_id_here"),
      timestamp: {
        $gte: new Date(Date.now() - 24*60*60*1000)
      }
    }
  },
  {
    $group: {
      _id: "$action",
      count: { $sum: 1 }
    }
  }
])

Isme humne:

Har action ko timestamp ke saath store kiya
Last 24 hours ka data nikalne ke liye $gte operator use kiya
Actions ki counting ke liye aggregation pipeline use kiya

Question 3. Hume apne website pe real-time search implement karna hai jahan user type karte hi results show hon. MongoDB mein text search kaise implement karein? Performance ke liye kya dhyan rakhna chahiye?
Answer :// First create text index
db.products.createIndex({ 
  name: "text", 
  description: "text" 
})

// Basic text search query
db.products.find({
  $text: {
    $search: "mobile phone samsung"
  }
}, {
  score: { $meta: "textScore" }
}).sort({
  score: { $meta: "textScore" }
})

// For partial word matching (better for real-time)
db.products.find({
  name: { 
    $regex: "^" + searchText,
    $options: "i"
  }
}).limit(10)

Real-time search ke liye important points:

Text index zaroor banayein - ye searching ko fast karta hai
Partial matching ke liye regex use karein
Results ko limit karein (like 10) taki performance acchi rahe
Heavy fields ko projection se exclude kar sakte hain

Question 4Shopping cart mein user ke items track karne hain. User logged in ho ya na ho, uska cart save rahna chahiye. Items add/remove karne pe cart update hona chahiye. Iska schema aur queries kaise banayenge?
Answer: 
// Cart Schema
{
  _id: ObjectId("..."),
  userId: ObjectId("..."),  // null for guest users
  sessionId: "guest_session_123", // for guest users
  status: "active",  // active, abandoned, converted
  items: [
    {
      productId: ObjectId("..."),
      quantity: 2,
      price: 1999.99,
      addedAt: ISODate("2025-01-20T10:30:00Z"),
      name: "Premium Headphones",  // denormalized for quick access
      image: "url_here"
    }
  ],
  totalAmount: 3999.98,
  lastUpdated: ISODate("2025-01-20T10:30:00Z"),
  createdAt: ISODate("2025-01-20T10:00:00Z")
}

// Add item to cart
db.carts.updateOne(
  { 
    userId: ObjectId("user_id_here"),
    status: "active"
  },
  {
    $push: {
      items: {
        productId: ObjectId("product_id"),
        quantity: 1,
        price: 1999.99,
        addedAt: new Date(),
        name: "Premium Headphones",
        image: "url_here"
      }
    },
    $inc: { totalAmount: 1999.99 },
    $set: { lastUpdated: new Date() }
  },
  { upsert: true }
)

// Remove item from cart
db.carts.updateOne(
  { userId: ObjectId("user_id_here") },
  {
    $pull: { 
      items: { productId: ObjectId("product_id") }
    },
    $inc: { totalAmount: -1999.99 },
    $set: { lastUpdated: new Date() }
  }
)

s implementation mein kuch important points hain:

Guest users ke liye sessionId use kiya hai
Product ki basic details cart mein hi store ki hain (denormalization)
Total amount real-time maintain kiya hai
Timestamps track kar rahe hain for analytics
Scenario: Social Media Post Analytics

Question 5. : Social media app mein posts ke analytics track karne hain - likes, shares, comments ki counting, trending posts find karna, user engagement calculate karna. Iske liye MongoDB mein kya approach use karein?

Answer :// Post Schema with Analytics
{
  _id: ObjectId("..."),
  userId: ObjectId("..."),
  content: "Post content here",
  metrics: {
    likes: 1500,
    shares: 300,
    comments: 250,
    views: 10000,
    engagementRate: 20.5  // (likes + shares + comments) / views * 100
  },
  engagementByHour: [
    {
      hour: ISODate("2025-01-20T01:00:00Z"),
      likes: 100,
      shares: 20,
      comments: 15
    }
    // ... 24 entries for each hour
  ],
  tags: ["tech", "mongodb", "coding"],
  createdAt: ISODate("2025-01-20T00:00:00Z")
}

// Find trending posts of last 24 hours
db.posts.aggregate([
  {
    $match: {
      createdAt: {
        $gte: new Date(Date.now() - 24*60*60*1000)
      }
    }
  },
  {
    $addFields: {
      trendingScore: {
        $add: [
          { $multiply: ["$metrics.likes", 1] },
          { $multiply: ["$metrics.shares", 2] },
          { $multiply: ["$metrics.comments", 1.5] }
        ]
      }
    }
  },
  {
    $sort: { trendingScore: -1 }
  },
  {
    $limit: 20
  }
])

// Calculate user engagement rate
db.posts.aggregate([
  {
    $match: {
      userId: ObjectId("user_id_here")
    }
  },
  {
    $group: {
      _id: "$userId",
      totalPosts: { $sum: 1 },
      totalEngagement: {
        $sum: {
          $add: [
            "$metrics.likes",
            "$metrics.shares",
            "$metrics.comments"
          ]
        }
      },
      totalViews: { $sum: "$metrics.views" }
    }
  },
  {
    $project: {
      engagementRate: {
        $multiply: [
          { $divide: ["$totalEngagement", "$totalViews"] },
          100
        ]
      }
    }
  }
])

Is implementation mein:

Har post ke metrics real-time update hote hain
Hourly engagement track kiya hai time-series analysis ke liye
Trending posts ke liye custom scoring system banaya hai
User engagement calculate karne ke liye aggregation pipeline use kiya hai

Question 6. Users ko different types ki notifications bhejni hain - new message, friend request, post likes, etc. Notifications read/unread status track karna hai, aur purani notifications archive karni hain. Iska system kaise design karein?
Answer : // Notification Schema
{
  _id: ObjectId("..."),
  userId: ObjectId("..."),
  type: "NEW_MESSAGE",  // NEW_MESSAGE, FRIEND_REQUEST, POST_LIKE
  status: "UNREAD",     // UNREAD, READ, ARCHIVED
  data: {
    senderId: ObjectId("..."),
    senderName: "John Doe",
    messagePreview: "Hey, how are you?",
    postId: ObjectId("..."),  // if notification is about a post
    actionType: "LIKE"        // specific action that triggered notification
  },
  priority: 1,  // 1: High, 2: Medium, 3: Low
  createdAt: ISODate("2025-01-20T10:30:00Z"),
  readAt: null,
  expiresAt: ISODate("2025-02-20T10:30:00Z")
}

// Get unread notifications for user
db.notifications.find({
  userId: ObjectId("user_id_here"),
  status: "UNREAD",
  expiresAt: { $gt: new Date() }
}).sort({ priority: 1, createdAt: -1 })

// Mark notifications as read
db.notifications.updateMany(
  {
    userId: ObjectId("user_id_here"),
    _id: { $in: [/* array of notification ids */] }
  },
  {
    $set: {
      status: "READ",
      readAt: new Date()
    }
  }
)

// Archive old notifications
db.notifications.updateMany(
  {
    createdAt: { 
      $lt: new Date(Date.now() - 30*24*60*60*1000) 
    },
    status: "READ"
  },
  {
    $set: { status: "ARCHIVED" }
  }
)

// Get notification counts by type
db.notifications.aggregate([
  {
    $match: {
      userId: ObjectId("user_id_here"),
      status: "UNREAD"
    }
  },
  {
    $group: {
      _id: "$type",
      count: { $sum: 1 }
    }
  }
])
Is notification system mein key features hain:

Different types ki notifications handle kar sakte hain
Priority based sorting possible hai
Notifications auto-expire ho sakti hain
Old notifications archive ho jati hain
Type-wise counting easily mil jati hai

Best practices:

Indexes on userId, status, and createdAt
TTL index on expiresAt field
Batch processing for archival
Caching for frequent queries